        -:    0:Source:src/chtrie.c
        -:    1:#include <stddef.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <limits.h>
        -:    4:#include <errno.h>
        -:    5:#include "chtrie.h"
        -:    6:#define SZ_MAX ((size_t)-1)
        -:    7:#define MIN(x, y) ((x)<(y)?(x):(y))
        -:    8:
    #####:    9:chtrie *chtrie_alloc(size_t n, size_t m)
        -:   10:{
        -:   11:	chtrie *tr;
        -:   12:
    #####:   13:	if (n < 1) n = 1;
    #####:   14:	if (m < 1) m = 1;
    #####:   15:	if (n > INT_MAX || m > INT_MAX) {
    #####:   16:		errno = ERANGE;
    #####:   17:		goto err;
        -:   18:	}
    #####:   19:	if (MIN(INT_MAX, SZ_MAX) - (n-1) < (n-1) / 3) {
    #####:   20:		errno = ERANGE;
    #####:   21:		goto err;
        -:   22:	}
    #####:   23:	if (!(tr = calloc(1, sizeof *tr)))
    #####:   24:		goto err;
    #####:   25:	tr->maxn = n;
    #####:   26:	tr->alphsz = m;
    #####:   27:	tr->ecap = (n-1) + (n-1)/3;
    #####:   28:	if (!(tr->etab = calloc(tr->ecap, sizeof tr->etab[0])))
    #####:   29:		goto free_tr;
    #####:   30:	if (!(tr->idxpool = calloc(n, sizeof tr->idxpool[0])))
    #####:   31:		goto free_ecap;
    #####:   32:	tr->idxmax = 1;
    #####:   33:	tr->idxptr = tr->idxpool;
    #####:   34:	return tr;
    #####:   35:free_ecap:
    #####:   36:	free(tr->etab);
    #####:   37:free_tr:
    #####:   38:	free(tr);
    #####:   39:err:
    #####:   40:	return NULL;
        -:   41:}
        -:   42:
    #####:   43:int chtrie_walk(chtrie *tr, int from, int sym, int creat)
        -:   44:{
        -:   45:	struct chtrie_edge *p;
        -:   46:	unsigned long h;
        -:   47:
    #####:   48:	h = (unsigned long)from*tr->alphsz + sym;
    #####:   49:	h %= tr->ecap;
    #####:   50:	for (p = tr->etab[h]; p; p = p->next)
    #####:   51:		if (p->from == from && p->sym == sym)
    #####:   52:			return p->to;
    #####:   53:	if (creat) {
    #####:   54:		if (tr->idxptr == tr->idxpool && tr->idxmax >= tr->maxn) {
    #####:   55:			errno = ENOMEM;
    #####:   56:			return -1;
        -:   57:		}
    #####:   58:		if (!(p = malloc(sizeof *p)))
    #####:   59:			return -1;
    #####:   60:		p->next = tr->etab[h];
    #####:   61:		tr->etab[h] = p;
    #####:   62:		p->from = from;
    #####:   63:		p->sym = sym;
    #####:   64:		if (tr->idxptr != tr->idxpool)
    #####:   65:			p->to = *--tr->idxptr;
        -:   66:		else
    #####:   67:			p->to = tr->idxmax++;
    #####:   68:		return p->to;
        -:   69:	}
    #####:   70:	return -1;
        -:   71:}
        -:   72:
    #####:   73:void chtrie_del(chtrie *tr, int from, int sym)
        -:   74:{
        -:   75:	struct chtrie_edge *p, *q;
        -:   76:	unsigned long h;
        -:   77:
    #####:   78:	h = (unsigned long)from*tr->alphsz + sym;
    #####:   79:	h %= tr->ecap;
    #####:   80:	for (p = tr->etab[h], q = NULL; p; q = p, p = p->next)
    #####:   81:		if (p->from == from && p->sym == sym)
    #####:   82:			break;
    #####:   83:	if (!p)
    #####:   84:		return;
    #####:   85:	if (q)
    #####:   86:		q->next = p->next;
        -:   87:	else
    #####:   88:		tr->etab[h] = NULL;
    #####:   89:	*tr->idxptr++ = p->to;
    #####:   90:	free(p);
        -:   91:}
        -:   92:
    #####:   93:void chtrie_free(chtrie *tr)
        -:   94:{
        -:   95:	struct chtrie_edge *p, *q;
        -:   96:	int i;
        -:   97:
    #####:   98:	for (i = 0; i < tr->ecap; i++) {
    #####:   99:		p = tr->etab[i];
    #####:  100:		while (p) {
    #####:  101:			q = p->next;
    #####:  102:			free(p);
    #####:  103:			p = q;
        -:  104:		}
        -:  105:	}
    #####:  106:	free(tr->etab);
    #####:  107:	free(tr->idxpool);
    #####:  108:	free(tr);
    #####:  109:}
