        -:    0:Source:tests/test_c_fsm.c
        -:    1:/* MIT License
        -:    2: *
        -:    3: * Copyright (C) 2024  Haju Schulz <haju@schulznorbert.de>
        -:    4: *
        -:    5: * Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    6: * of this software and associated documentation files (the "Software"), to deal
        -:    7: * in the Software without restriction, including without limitation the rights
        -:    8: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    9: * copies of the Software, and to permit persons to whom the Software is
        -:   10: * furnished to do so, subject to the following conditions:
        -:   11: *
        -:   12: * The above copyright notice and this permission notice shall be included in all
        -:   13: * copies or substantial portions of the Software.
        -:   14: *
        -:   15: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   16: * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   17: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   18: * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   19: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   20: * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        -:   21: * SOFTWARE.
        -:   22: */
        -:   23:
        -:   24:/*******************************************************************************
        -:   25:    DESCRIPTION
        -:   26:*******************************************************************************/
        -:   27:/**
        -:   28: * @brief  CFSM test suite
        -:   29: *
        -:   30: * @addtogroup tests
        -:   31: *
        -:   32: * @{
        -:   33: */
        -:   34:
        -:   35:/******************************************************************************
        -:   36: * Includes
        -:   37: *****************************************************************************/
        -:   38:
        -:   39:#include <string.h>
        -:   40:#include <Unity-2.5.2/src/unity.h>
        -:   41:
        -:   42:#include "../src/c_fsm.h"
        -:   43:
        -:   44:/******************************************************************************
        -:   45: * Macros
        -:   46: *****************************************************************************/
        -:   47:
        -:   48:/******************************************************************************
        -:   49: * Types and Classes
        -:   50: *****************************************************************************/
        -:   51:typedef struct StateOperationCounter_
        -:   52:{
        -:   53:    int enterCalls;
        -:   54:    int leaveCalls;
        -:   55:    int eventCalls;
        -:   56:    int processCalls;
        -:   57:    int lastEventId;
        -:   58:} StateOperationCounter;
        -:   59:
        -:   60:/******************************************************************************
        -:   61: * Prototypes
        -:   62: *****************************************************************************/
        -:   63:static void State_only_onEnter(cfsm_Ctx * fsm);
        -:   64:
        -:   65:static void State_A_onEvent(cfsm_Ctx * fsm, int eventId);
        -:   66:static void State_A_onProcess(cfsm_Ctx * fsm);
        -:   67:static void State_A_onLeave(cfsm_Ctx * fsm);
        -:   68:static void State_A_onEnter(cfsm_Ctx * fsm);
        -:   69:
        -:   70:static void State_B_onEvent(cfsm_Ctx * fsm, int eventId);
        -:   71:static void State_B_onProcess(cfsm_Ctx * fsm);
        -:   72:static void State_B_onLeave(cfsm_Ctx * fsm);
        -:   73:static void State_B_onEnter(cfsm_Ctx * fsm);
        -:   74:
        -:   75:/******************************************************************************
        -:   76: * Variables
        -:   77: *****************************************************************************/
        -:   78:
        -:   79:static cfsm_Ctx fsmInstance;  /**< fsm instance used in tests */
        -:   80:static StateOperationCounter state_A;
        -:   81:static StateOperationCounter state_B;
        -:   82:static uint8_t dummyInstanceData = 42u;
        -:   83:
        -:   84:/******************************************************************************
        -:   85: * External functions
        -:   86: *****************************************************************************/
        -:   87:
        4:   88:void setUp(void)
        -:   89:{
        4:   90:    cfsm_init(&fsmInstance, NULL);
        -:   91:
        -:   92:    memset(&state_A, 0, sizeof(state_A));
        -:   93:    memset(&state_B, 0, sizeof(state_A));
        4:   94:}
        -:   95:
        4:   96:void tearDown(void)
        -:   97:{
        4:   98:}
        -:   99:
    #####:  100:void test_cfsm_version()
        -:  101:{
    #####:  102:    TEST_ASSERT_EQUAL(0, CFSM_VER_MAJOR);
    #####:  103:    TEST_ASSERT_EQUAL(2, CFSM_VER_MINOR);
    #####:  104:    TEST_ASSERT_EQUAL(0, CFSM_VER_PATCH);
    #####:  105:}
        -:  106:
        1:  107:void test_cfsm_init_should_clear_handler(void)
        -:  108:{
        -:  109:    memset(&fsmInstance, -1, sizeof(fsmInstance));  /* corrupt content */
        -:  110:
        1:  111:    cfsm_init(&fsmInstance, &dummyInstanceData);
        -:  112:
        1:  113:    TEST_ASSERT_EQUAL_PTR(NULL, fsmInstance.onEvent);
        1:  114:    TEST_ASSERT_EQUAL_PTR(NULL, fsmInstance.onProcess);
        1:  115:    TEST_ASSERT_EQUAL_PTR(NULL, fsmInstance.onLeave);
        -:  116:
        1:  117:    TEST_ASSERT_EQUAL_PTR(&dummyInstanceData, fsmInstance.ctxPtr);
        -:  118:
        1:  119:}
        -:  120:
        1:  121:void test_cfsm_init_is_safe_to_use(void)
        -:  122:{
        1:  123:    cfsm_init(&fsmInstance, NULL);
        -:  124:
        -:  125:    /* should not crash */
        1:  126:    cfsm_process(&fsmInstance);
        1:  127:    cfsm_event(&fsmInstance, 0x12345678);
        1:  128:}
        -:  129:
        1:  130:void test_cfsm_transition_should_set_enter_handler_only(void)
        -:  131:{
        1:  132:    cfsm_transition(&fsmInstance, State_only_onEnter);
        1:  133:    TEST_ASSERT_EQUAL_PTR(fsmInstance.onEvent, NULL);
        1:  134:    TEST_ASSERT_EQUAL_PTR(fsmInstance.onProcess, NULL);
        1:  135:    TEST_ASSERT_EQUAL_PTR(fsmInstance.onLeave, NULL);
        1:  136:}
        -:  137:
    #####:  138:void test_cfs_process()
        -:  139:{
    #####:  140:    cfsm_transition(&fsmInstance, State_A_onEnter);
        -:  141:
    #####:  142:    TEST_ASSERT_EQUAL_INT(state_A.enterCalls, 1);
    #####:  143:    TEST_ASSERT_EQUAL_INT(state_A.leaveCalls, 0);
    #####:  144:    TEST_ASSERT_EQUAL_INT(state_A.processCalls, 0);
    #####:  145:    TEST_ASSERT_EQUAL_INT(state_A.eventCalls, 0);
    #####:  146:    TEST_ASSERT_EQUAL_INT(state_A.lastEventId, 0);
        -:  147:
    #####:  148:    for (int i = 0; i < 10; ++i)
        -:  149:    {
    #####:  150:        cfsm_process(&fsmInstance);
    #####:  151:        TEST_ASSERT_EQUAL_INT(state_A.lastEventId, i);
        -:  152:    }
    #####:  153:    TEST_ASSERT_EQUAL_INT(state_A.enterCalls, 1);
    #####:  154:    TEST_ASSERT_EQUAL_INT(state_A.leaveCalls, 0);
    #####:  155:    TEST_ASSERT_EQUAL_INT(state_A.processCalls, 10);
    #####:  156:    TEST_ASSERT_EQUAL_INT(state_A.eventCalls, 0);
    #####:  157:}
        -:  158:
    #####:  159:void test_cfs_signalEvent()
        -:  160:{
    #####:  161:    cfsm_transition(&fsmInstance, State_A_onEnter);
        -:  162:
    #####:  163:    TEST_ASSERT_EQUAL_INT(state_A.enterCalls, 1);
    #####:  164:    TEST_ASSERT_EQUAL_INT(state_A.leaveCalls, 0);
    #####:  165:    TEST_ASSERT_EQUAL_INT(state_A.processCalls, 0);
    #####:  166:    TEST_ASSERT_EQUAL_INT(state_A.eventCalls, 0);
        -:  167:
    #####:  168:    for (int i = 0; i < 10; ++i)
        -:  169:    {
    #####:  170:        cfsm_event(&fsmInstance, i);
        -:  171:    }
    #####:  172:    TEST_ASSERT_EQUAL_INT(state_A.enterCalls, 1);
    #####:  173:    TEST_ASSERT_EQUAL_INT(state_A.leaveCalls, 0);
    #####:  174:    TEST_ASSERT_EQUAL_INT(state_A.processCalls, 0);
    #####:  175:    TEST_ASSERT_EQUAL_INT(state_A.eventCalls, 10);
    #####:  176:}
        -:  177:
        1:  178:void test_cfs_transition_A_B_A(void)
        -:  179:{
        1:  180:    cfsm_transition(&fsmInstance, State_A_onEnter);
        -:  181:
        1:  182:    TEST_ASSERT_EQUAL_PTR(fsmInstance.onEvent, State_A_onEvent);
        1:  183:    TEST_ASSERT_EQUAL_PTR(fsmInstance.onProcess, State_A_onProcess);
        1:  184:    TEST_ASSERT_EQUAL_PTR(fsmInstance.onLeave, State_A_onLeave);
        -:  185:
        1:  186:    TEST_ASSERT_EQUAL_INT(state_A.enterCalls, 1);
        1:  187:    TEST_ASSERT_EQUAL_INT(state_A.leaveCalls, 0);
        1:  188:    TEST_ASSERT_EQUAL_INT(state_A.processCalls, 0);
        1:  189:    TEST_ASSERT_EQUAL_INT(state_A.eventCalls, 0);
        -:  190:
        1:  191:    TEST_ASSERT_EQUAL_INT(state_B.enterCalls, 0);
        1:  192:    TEST_ASSERT_EQUAL_INT(state_B.leaveCalls, 0);
        1:  193:    TEST_ASSERT_EQUAL_INT(state_B.processCalls, 0);
        1:  194:    TEST_ASSERT_EQUAL_INT(state_B.eventCalls, 0);
        -:  195:
        1:  196:    cfsm_transition(&fsmInstance, State_B_onEnter);
        -:  197:
        1:  198:    TEST_ASSERT_EQUAL_PTR(fsmInstance.onEvent, State_B_onEvent);
        1:  199:    TEST_ASSERT_EQUAL_PTR(fsmInstance.onProcess, State_B_onProcess);
        1:  200:    TEST_ASSERT_EQUAL_PTR(fsmInstance.onLeave, State_B_onLeave);
        -:  201:
        1:  202:    TEST_ASSERT_EQUAL_INT(state_A.enterCalls, 1);
        1:  203:    TEST_ASSERT_EQUAL_INT(state_A.leaveCalls, 1);
        1:  204:    TEST_ASSERT_EQUAL_INT(state_A.processCalls, 0);
        1:  205:    TEST_ASSERT_EQUAL_INT(state_A.eventCalls, 0);
        -:  206:
        1:  207:    TEST_ASSERT_EQUAL_INT(state_B.enterCalls, 1);
        1:  208:    TEST_ASSERT_EQUAL_INT(state_B.leaveCalls, 0);
        1:  209:    TEST_ASSERT_EQUAL_INT(state_B.processCalls, 0);
        1:  210:    TEST_ASSERT_EQUAL_INT(state_B.eventCalls, 0);
        -:  211:
        1:  212:    cfsm_transition(&fsmInstance, State_A_onEnter);
        -:  213:
        1:  214:    TEST_ASSERT_EQUAL_PTR(fsmInstance.onEvent, State_A_onEvent);
        1:  215:    TEST_ASSERT_EQUAL_PTR(fsmInstance.onProcess, State_A_onProcess);
        1:  216:    TEST_ASSERT_EQUAL_PTR(fsmInstance.onLeave, State_A_onLeave);
        -:  217:
        1:  218:    TEST_ASSERT_EQUAL_INT(state_A.enterCalls, 2);
        1:  219:    TEST_ASSERT_EQUAL_INT(state_A.leaveCalls, 1);
        1:  220:    TEST_ASSERT_EQUAL_INT(state_A.processCalls, 0);
        1:  221:    TEST_ASSERT_EQUAL_INT(state_A.eventCalls, 0);
        -:  222:
        1:  223:    TEST_ASSERT_EQUAL_INT(state_B.enterCalls, 1);
        1:  224:    TEST_ASSERT_EQUAL_INT(state_B.leaveCalls, 1);
        1:  225:    TEST_ASSERT_EQUAL_INT(state_B.processCalls, 0);
        1:  226:    TEST_ASSERT_EQUAL_INT(state_B.eventCalls, 0);
        1:  227:}
        -:  228:
        1:  229:int main(void)
        -:  230:{
        1:  231:    UNITY_BEGIN();
        -:  232:
        1:  233:    RUN_TEST(test_cfsm_init_is_safe_to_use);
        1:  234:    RUN_TEST(test_cfsm_init_should_clear_handler);
        1:  235:    RUN_TEST(test_cfsm_transition_should_set_enter_handler_only);
        1:  236:    RUN_TEST(test_cfs_transition_A_B_A);
        -:  237:
        1:  238:    return UNITY_END();
        -:  239:}
        -:  240:
        -:  241:/******************************************************************************
        -:  242: * Local functions
        -:  243: *****************************************************************************/
        1:  244:static void State_only_onEnter(cfsm_Ctx * fsm)
        -:  245:{
        -:  246:    (void)fsm;
        1:  247:}
        -:  248:
        2:  249:static void State_A_onEnter(cfsm_Ctx * fsm)
        -:  250:{
        2:  251:    fsm->onEvent = State_A_onEvent;
        2:  252:    fsm->onLeave = State_A_onLeave;
        2:  253:    fsm->onProcess = State_A_onProcess;
        -:  254:
        2:  255:    state_A.enterCalls++;
        2:  256:}
        -:  257:
    #####:  258:static void State_A_onEvent(cfsm_Ctx * fsm, int eventId)
        -:  259:{
        -:  260:    (void)fsm;
        -:  261:    (void)eventId;
        -:  262:
    #####:  263:    state_A.eventCalls++;
    #####:  264:}
        -:  265:
    #####:  266:static void State_A_onProcess(cfsm_Ctx * fsm)
        -:  267:{
        -:  268:    (void)fsm;
        -:  269:
    #####:  270:    state_A.processCalls++;
    #####:  271:}
        -:  272:
        1:  273:static void State_A_onLeave(cfsm_Ctx * fsm)
        -:  274:{
        -:  275:    (void)fsm;
        -:  276:
        1:  277:    state_A.leaveCalls++;
        1:  278:}
        -:  279:
        1:  280:static void State_B_onEnter(cfsm_Ctx * fsm)
        -:  281:{
        1:  282:    fsm->onEvent = State_B_onEvent;
        1:  283:    fsm->onLeave = State_B_onLeave;
        1:  284:    fsm->onProcess = State_B_onProcess;
        1:  285:    state_B.enterCalls++;
        1:  286:}
        -:  287:
    #####:  288:static void State_B_onEvent(cfsm_Ctx * fsm, int eventId)
        -:  289:{
        -:  290:    (void)fsm;
        -:  291:    (void)eventId;
        -:  292:
    #####:  293:    state_B.eventCalls++;
    #####:  294:}
        -:  295:
    #####:  296:static void State_B_onProcess(cfsm_Ctx * fsm)
        -:  297:{
        -:  298:    (void)fsm;
        -:  299:
    #####:  300:    state_B.processCalls++;
    #####:  301:}
        -:  302:
        1:  303:static void State_B_onLeave(cfsm_Ctx * fsm)
        -:  304:{
        -:  305:    (void)fsm;
        -:  306:
        1:  307:    state_B.leaveCalls++;
        1:  308:}
