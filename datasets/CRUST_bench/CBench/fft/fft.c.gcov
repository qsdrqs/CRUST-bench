        -:    0:Source:src/fft.c
        -:    1:#include "fft.h"
        -:    2:
        -:    3:#include <assert.h>
        -:    4:#include <limits.h>
        -:    5:#include <math.h>
        -:    6:
        -:    7:#define INTBITS(t)  (sizeof (t) * CHAR_BIT)
        -:    8:
        -:    9:
        -:   10:#if defined (__GNUC__) || defined (__clang__)
        -:   11:#define fft_clz(n)                                \
        -:   12:  _Generic(n,                                     \
        -:   13:        unsigned int: __builtin_clz(n),           \
        -:   14:        unsigned long: __builtin_clzl(n),         \
        -:   15:        unsigned long long: __builtin_clzll(n))
        -:   16:
        -:   17:#define likely(expr)    __builtin_expect(!!(expr), 1)
        -:   18:#define unlikely(expr)  __builtin_expect(!!(expr), 0)
        -:   19:#else
        -:   20:
        -:   21:static inline size_t fft_clz(size_t n) {
        -:   22:  size_t count = 1;
        -:   23:  size_t half = INTBITS(size_t) / 2;
        -:   24:  do {
        -:   25:    while (!(n >> half))
        -:   26:      half >>= 1;
        -:   27:    n >>= half;
        -:   28:    count += half;
        -:   29:  } while (half >>= 1);
        -:   30:  return INTBITS(size_t) - count;
        -:   31:}
        -:   32:
        -:   33:
        -:   34:#define likely(expr)    (expr)
        -:   35:#define unlikely(expr)  (expr)
        -:   36:#endif
        -:   37:
       6*:   38:static inline size_t next_reversed_n(size_t reversed_n, size_t shift) {
       6*:   39:  reversed_n <<= shift;
       6*:   40:  size_t count_leading_ones = fft_clz(~reversed_n);
       6*:   41:  reversed_n <<= count_leading_ones;  /* remove leading ones */
       6*:   42:  reversed_n |= (size_t)1 << (INTBITS(size_t) - 1);
       6*:   43:  reversed_n >>= (shift + count_leading_ones);
       6*:   44:  return reversed_n;
        -:   45:}
        -:   46:
    #####:   47:static inline void rader(const fft_complex_t *restrict array, fft_complex_t *restrict target, size_t logsize) {
    #####:   48:  size_t size = (size_t)1 << logsize;
        -:   49:  /* how many bits should be shift to move the number to the most significant bit */
    #####:   50:  size_t shift = INTBITS(size_t) - logsize;
    #####:   51:  for (size_t n = 0, reversed_n = 0; n < size; ++n) {
    #####:   52:    FFT_COMPLEX_COPY(target[reversed_n], array[n]);
        -:   53:
        -:   54:    /* get next reversed_n */
    #####:   55:    reversed_n = next_reversed_n(reversed_n, shift);
        -:   56:  }
        -:   57:}
        -:   58:
        1:   59:static inline void rader_inplace(fft_complex_t *array, size_t logsize) {
        1:   60:  size_t size = (size_t)1 << logsize;
        1:   61:  size_t shift = INTBITS(size_t) - logsize;
        -:   62:  /* nothing should be done for 0 and 0b111...11(size - 1). */
        7:   63:  for (size_t n = 1, reversed_n = size >> 1; n < size - 1; ++n) {
        6:   64:    if (n < reversed_n)
        2:   65:      FFT_COMPLEX_SWAP(array[n], array[reversed_n]);
        -:   66:
        -:   67:    /* get next reversed_n */
        6:   68:    reversed_n = next_reversed_n(reversed_n, shift);
        -:   69:  }
        1:   70:}
        -:   71:
        -:   72:#define DO_BUTTERFLY(begin, end, step) do {                       \
        -:   73:  fft_complex_t unit;                                             \
        -:   74:  FFT_COMPLEX_UNITROOT_RECIP(unit, step);                         \
        -:   75:  const size_t half = (step) / 2;                                 \
        -:   76:  for (fft_complex_t *p = (begin); p != (end); p += (step)) {     \
        -:   77:    /* i == 0, j == half */                                       \
        -:   78:    fft_complex_t t, u;                                           \
        -:   79:    FFT_COMPLEX_COPY(t, p[half]);                                 \
        -:   80:    FFT_COMPLEX_COPY(u, p[0]);                                    \
        -:   81:    FFT_COMPLEX_ADD(p[0], u, t);                                  \
        -:   82:    FFT_COMPLEX_SUB(p[half], u, t);                               \
        -:   83:    if (half <= 1) continue;                                      \
        -:   84:    /* i == 1, j == half + 1 */                                   \
        -:   85:    fft_complex_t root;                                           \
        -:   86:    FFT_COMPLEX_COPY(root, unit);                                 \
        -:   87:    FFT_COMPLEX_MUL(t, root, p[half + 1]);                        \
        -:   88:    FFT_COMPLEX_COPY(u, p[1]);                                    \
        -:   89:    FFT_COMPLEX_ADD(p[1], u, t);                                  \
        -:   90:    FFT_COMPLEX_SUB(p[half + 1], u, t);                           \
        -:   91:    for (size_t i = 2, j = half + 2; i < half; ++i, ++j) {        \
        -:   92:      FFT_COMPLEX_SELFMUL(root, unit);                            \
        -:   93:      fft_complex_t t, u;                                         \
        -:   94:      FFT_COMPLEX_MUL(t, root, p[j]);                             \
        -:   95:      FFT_COMPLEX_COPY(u, p[i]);                                  \
        -:   96:      FFT_COMPLEX_ADD(p[i], u, t);                                \
        -:   97:      FFT_COMPLEX_SUB(p[j], u, t);                                \
        -:   98:    }                                                             \
        -:   99:  }                                                               \
        -:  100:} while (0)
        -:  101:
        1:  102:static void fft_raw(fft_complex_t *x, size_t logsize) {
        1:  103:  if (unlikely(logsize == 0))
        -:  104:    return;
        -:  105:
        1:  106:  fft_complex_t *begin = x;
        1:  107:  fft_complex_t *end = begin + ((size_t)1 << logsize);
        -:  108:
        5:  109:  DO_BUTTERFLY(begin, end, 2);
        -:  110:
        1:  111:  if (unlikely(logsize == 1)) /* size == 2 ? */
        -:  112:    return;
        -:  113:
        3:  114:  DO_BUTTERFLY(begin, end, 4);
        -:  115:
        1:  116:  if (unlikely(logsize == 2)) /* size == 4 ? */
        -:  117:    return;
        -:  118:
        -:  119:  /* do generic butterfly in a loop */
        2:  120:  for (size_t step = 8; step <= (size_t)1 << logsize; step *= 2)
       4*:  121:    DO_BUTTERFLY(begin, end, step);
        -:  122:
        -:  123:}
        -:  124:
    #####:  125:void fft(const fft_complex_t *restrict x, fft_complex_t *restrict X, size_t logsize) {
    #####:  126:  rader(x, X, logsize);
    #####:  127:  fft_raw(X, logsize);
    #####:  128:}
        -:  129:
        1:  130:void fft_inplace(fft_complex_t *x, size_t logsize) {
        1:  131:  rader_inplace(x, logsize);
        1:  132:  fft_raw(x, logsize);
        1:  133:}
